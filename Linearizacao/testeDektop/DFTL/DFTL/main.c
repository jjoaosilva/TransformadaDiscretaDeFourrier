#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

/* Prototipos de funcoes privadas */
static void test_dft(int n);
static void dft(const float *inreal, const float *inimag, float *outreal, float *outimag, bool inverse, int n);

/* Declaracao das variaveis globais */
/*
*  amostrasR e amostrasI contem as amostras a serem utilizadas pela DFT.
*/
float amostrasR[512] = {1.000000, 1.368125, 1.684547, 1.904827, 1.998027, 1.951056, 1.770513, 1.481754, 1.125333, 0.751310, -1.587785, -1.844328, -1.982287, -1.982287, -1.844328, -1.587785, -1.248690, -0.874667, -0.518246, -0.229487, 1.951056, 1.998027, 1.904827, 1.684547, 1.368125, 1.000000, 0.631875, 0.315453, 0.095173, 0.001973, -1.951056, -1.770513, -1.481754, -1.125333, -0.751310, -0.412215, -0.155672, -0.017713, -0.017713, -0.155672, 1.587785, 1.248690, 0.874667, 0.518246, 0.229487, 0.048943, 0.001973, 0.095173, 0.315453, 0.631875, -1.000000, -0.631875, -0.315453, -0.095173, -0.001973, -0.048943, -0.229487, -0.518246, -0.874667, -1.248690, 0.412215, 0.155672, 0.017713, 0.017713, 0.155672, 0.412215, 0.751310, 1.125333, 1.481754, 1.770513, -0.048943, -0.001973, -0.095173, -0.315453, -0.631875, -1.000000, -1.368125, -1.684547, -1.904827, -1.998027, 0.048943, 0.229487, 0.518246, 0.874667, 1.248690, 1.587785, 1.844328, 1.982287, 1.982287, 1.844328, -0.412215, -0.751310, -1.125333, -1.481754, -1.770513, -1.951056, -1.998027, -1.904827, -1.684547, -1.368125, 1.000000, 1.368125, 1.684547, 1.904827, 1.998027, 1.951056, 1.770513, 1.481754, 1.125333, 0.751310, -1.587785, -1.844328, -1.982287, -1.982287, -1.844328, -1.587785, -1.248690, -0.874667, -0.518246, -0.229487, 1.951056, 1.998027, 1.904827, 1.684547, 1.368125, 1.000000, 0.631875, 0.315453, 0.095173, 0.001973, -1.951056, -1.770513, -1.481754, -1.125333, -0.751310, -0.412215, -0.155672, -0.017713, -0.017713, -0.155672, 1.587785, 1.248690, 0.874667, 0.518246, 0.229487, 0.048943, 0.001973, 0.095173, 0.315453, 0.631875, -1.000000, -0.631875, -0.315453, -0.095173, -0.001973, -0.048943, -0.229487, -0.518246, -0.874667, -1.248690, 0.412215, 0.155672, 0.017713, 0.017713, 0.155672, 0.412215, 0.751310, 1.125333, 1.481754, 1.770513, -0.048943, -0.001973, -0.095173, -0.315453, -0.631875, -1.000000, -1.368125, -1.684547, -1.904827, -1.998027, 0.048943, 0.229487, 0.518246, 0.874667, 1.248690, 1.587785, 1.844328, 1.982287, 1.982287, 1.844328, -0.412215, -0.751310, -1.125333, -1.481754, -1.770513, -1.951056, -1.998027, -1.904827, -1.684547, -1.368125, 1.000000, 1.368125, 1.684547, 1.904827, 1.998027, 1.951056, 1.770513, 1.481754, 1.125333, 0.751310, -1.587785, -1.844328, -1.982287, -1.982287, -1.844328, -1.587785, -1.248690, -0.874667, -0.518246, -0.229487, 1.951056, 1.998027, 1.904827, 1.684547, 1.368125, 1.000000, 0.631875, 0.315453, 0.095173, 0.001973, -1.951056, -1.770513, -1.481754, -1.125333, -0.751310, -0.412215, -0.155672, -0.017713, -0.017713, -0.155672, 1.587785, 1.248690, 0.874667, 0.518246, 0.229487, 0.048943, 0.001973, 0.095173, 0.315453, 0.631875, -1.000000, -0.631875, -0.315453, -0.095173, -0.001973, -0.048943, -0.229487, -0.518246, -0.874667, -1.248690, 0.412215, 0.155672, 0.017713, 0.017713, 0.155672, 0.412215, 0.751310, 1.125333, 1.481754, 1.770513, -0.048943, -0.001973, -0.095173, -0.315453, -0.631875, -1.000000, -1.368125, -1.684547, -1.904827, -1.998027, 0.048943, 0.229487, 0.518246, 0.874667, 1.248690, 1.587785, 1.844328, 1.982287, 1.982287, 1.844328, -0.412215, -0.751310, -1.125333, -1.481754, -1.770513, -1.951056, -1.998027, -1.904827, -1.684547, -1.368125, 1.000000, 1.368125, 1.684547, 1.904827, 1.998027, 1.951056, 1.770513, 1.481754, 1.125333, 0.751310, -1.587785, -1.844328, -1.982287, -1.982287, -1.844328, -1.587785, -1.248690, -0.874667, -0.518246, -0.229487, 1.951056, 1.998027, 1.904827, 1.684547, 1.368125, 1.000000, 0.631875, 0.315453, 0.095173, 0.001973, -1.951056, -1.770513, -1.481754, -1.125333, -0.751310, -0.412215, -0.155672, -0.017713, -0.017713, -0.155672, 1.587785, 1.248690, 0.874667, 0.518246, 0.229487, 0.048943, 0.001973, 0.095173, 0.315453, 0.631875, -1.000000, -0.631875, -0.315453, -0.095173, -0.001973, -0.048943, -0.229487, -0.518246, -0.874667, -1.248690, 0.412215, 0.155672, 0.017713, 0.017713, 0.155672, 0.412215, 0.751310, 1.125333, 1.481754, 1.770513, -0.048943, -0.001973, -0.095173, -0.315453, -0.631875, -1.000000, -1.368125, -1.684547, -1.904827, -1.998027, 0.048943, 0.229487, 0.518246, 0.874667, 1.248690, 1.587785, 1.844328, 1.982287, 1.982287, 1.844328, -0.412215, -0.751310, -1.125333, -1.481754, -1.770513, -1.951056, -1.998027, -1.904827, -1.684547, -1.368125, 1.000000, 1.368125, 1.684547, 1.904827, 1.998027, 1.951056, 1.770513, 1.481754, 1.125333, 0.751310, -1.587785, -1.844328, -1.982287, -1.982287, -1.844328, -1.587785, -1.248690, -0.874667, -0.518246, -0.229487, 1.951056, 1.998027, 1.904827, 1.684547, 1.368125, 1.000000, 0.631875, 0.315453, 0.095173, 0.001973, 0.048943, -1.770513, -1.481754, -1.125333, -0.751310, -0.412215, -0.155672, -0.017713, -0.017713, -0.155672, 1.587785, 1.248690, 0.874667, 0.518246, 0.229487, 0.048943, 0.001973, 0.095173, 0.315453, 0.631875, -1.000000, -0.631875, -0.315453, -0.095173, -0.001973, -0.048943, -0.229487, -0.518246, -0.874667, -1.248690, 0.412215, 0.155672, 0.017713, 0.017713, 0.155672, 0.412215, 0.751310, 1.125333, 1.481754, 1.770513, -0.048943, -0.001973, -0.095173, -0.315453, -0.631875, -1.000000, -1.368125, -1.684547, -1.904827, -1.998027, 0.048943, 0.229487, 0.518246, 0.874667, 1.248690, 1.587785, 1.844328, 1.982287, 1.982287, 1.844328, -0.412215, -0.751310, -1.125333, -1.481754, -1.770513, -1.951056, -1.998027, -1.904827, -1.684547, -1.368125, 1.000000, 1.368125, 1.684547, 1.904827, 1.998027, 1.951056, 1.770513, 1.481754, 1.125333, 0.751310, 0.412215, -1.844328};
float amostrasI[512] = {0.0};
/*
*  respostaR e respostaI irao armazenar as saidas da DFT.
*/
float respostaR[512] = {0.0};
float respostaI[512] = {0.0};

float senoL(double num){
    int flag = 1, cont = 1;
    if(num < 0){
        flag = -1;
        num *= -1;
    }
    while(num > 6){
        num = num - 6;
        cont++;
    }
    if      (num >= 0  && num <= 0.5) return  (0.958800*num + 0.000000)*flag*cont;
    else if (num > 0.5 && num <= 1  ) return  (0.724200*num + 0.117300)*flag*cont;
    else if (num > 1   && num <= 1.5) return  (0.312000*num + 0.529500)*flag*cont;
    else if (num > 1.5 && num <= 2  ) return  (-0.176400*num + 1.262100)*flag*cont;
    else if (num > 2   && num <= 2.5) return  (-0.621600*num + 2.152500)*flag*cont;
    else if (num > 2.5 && num <= 4  ) return  (-0.903533*num + 2.857333)*flag*cont;
    else if (num > 4   && num <= 4.5) return  (-0.441400*num + 1.008800)*flag*cont;
    else if (num > 4.5 && num <= 5  ) return  (0.037200*num - 1.144900)*flag*cont;
    else if (num > 5   && num <= 5.5) return  (0.506800*num - 3.492900)*flag*cont;
    else if (num > 5.5 && num <= 6  ) return  (0.852200*num - 5.392600)*flag*cont;
    else return 100000;
}

float cossenoL(double num){
    int flag = 1, cont = 1;
    if(num < 0){
        flag = -1;
        num *= -1;
    }
    while(num > 6){
        num = num - 6;
        cont++;
    }
    if      (num >= 0  && num <= 0.5) return  (-0.244800*num + 1.000000)*flag;
    else if (num > 0.5 && num <= 1  ) return  (-0.674600*num + 1.214900)*flag;
    else if (num > 1   && num <= 2.5) return  (-0.894267*num + 1.434567)*flag;
    else if (num > 2.5 && num <= 3  ) return  (-0.377800*num + 0.143400)*flag;
    else if (num > 3   && num <= 3.5) return  (0.107000*num - 1.311000)*flag;
    else if (num > 3.5 && num <= 4  ) return  (0.565800*num - 2.916800)*flag;
    else if (num > 4   && num <= 5.5) return  (0.908200*num - 4.286400)*flag;
    else if (num > 5.5 && num <= 6  ) return  (10.493200*num - 61.99900)*flag;
    else return 100000;
}

int main(void) {
	int i = 1 << 9;                // Define o numero de pontos da DFT: 1 << N == 2^N.
	printf("Inicio do teste.");
    test_dft(i);
	printf("Fim do teste.");

	return EXIT_SUCCESS;
}

/* Funcao de realiza a chamada do calculo e gravacao das saidas em .txt.*/
static void test_dft(int n) {

    FILE	*ptr;
    int i = 0;

	dft(amostrasR, amostrasI, respostaR, respostaI, false, n);   // Chamada da DFT.

    ptr = fopen("RespostasDFTSemb.txt", "w++");                  // Logica para gravacao dos arquivos em .txt.
	for (i = 0; i < (n/2)+1; i++){
        fprintf(ptr, "\n %f %f", respostaR[i], respostaI[i]);    // Os pares real + imag sao salvos na mesma linha para melhor
	}                                                            // analise.
	fclose(ptr);
}

/* Funcao de realiza calculo da DFT. */
/*
*  Parametros:
*       - inreal e inimag: sao ponteiros para as amostras.
*       - outreal outimag: sao ponteiros para os resultados computados.
*       - inverse        : indica se a DFT e direta ou inversa.
*       - n              : indica o numero de pontos.
*/
static void dft(const float *inreal, const float *inimag, float *outreal, float *outimag, bool inverse, int n) {
	float coef = (inverse ? 2 : -2) * M_PI;           // 2pi caso seja transformada direta, -2pi caso seja transformada inversa.
	int k;
	for (k = 0; k < (n/2)+1; k++) {
		float sumreal = 0;
		float sumimag = 0;
		int t;
		for (t = 0; t < n; t++) {
			float angle = coef * ((long long)t * k % n) / n;
//			printf("%f", angle);

//            printf("%f: SENO MATH: %f, SENOL: %f\n", angle,sin(angle), senoL(angle));
//            printf("COS  MATH: %f,  COSL: %f\n", cos(angle),cossenoL(angle));
//			sumreal += inreal[t]*cos(angle) - inimag[t]*sin(angle);  // Calculos da DFT.
//			sumimag += inreal[t]*sin(angle) + inimag[t]*cos(angle);
			sumreal += inreal[t]*cos(angle) - inimag[t]*senoL(angle);  // Calculos da DFT.
			sumimag += inreal[t]*senoL(angle) + inimag[t]*cos(angle);
		}
		outreal[k] = sumreal;
		outimag[k] = sumimag;
	}
}
